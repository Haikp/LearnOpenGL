# Contents of this Branch
## Thoughts on the Module
At this point, I have yet to go through the entirety of the module. Cameras feels like its quite a big stepping point in OpenGL, and I do think its one of the more exciting modules being that I get to finally "interact" with what I've created. However, I feel like I should take the time to brush up on geometry again.

Theres a point in the module where we make the camera rotate in a circle, looking at the world space origin. The code in itself is straight forward, but I really struggled with trying to understand how the x axis moving along the values of sine and the z axis moving along the values of cos would result in a circle. This seems like something thats very simple, but I simply forgot about it. Haven't touched geometry in years. If I'm having a hard time with this, I should probably review a bit before continuing. This really shouldn't take too long unlike how I spent a few days with linear algebra since I was fairly confident in my geomtry skills years ago, but who knows something might go wrong in reviewing.

## Module is Now Completed
So the amount of content absorbed in this module was quite a lot in my opinion, and I'm writing this now in attempt to digest what I just read through. Usually I would complete the exercises first, but this time around lets just swap it for the sake of learning and organization.

Things Covered This Module (in no particular order):
1) Delta Time
2) glm::lookAt
    - relevant camera information needed
    - camera movement
    - cursor and scroll wheel input
3) Concept of yaw, pitch, and roll (falls under cursor movement, but this was a lot to take in)
    - relevant unit circle math to understand computations

Going through information learned, delta time is something that I was previously aware of from having some game development experience. Using the frame rate as a way to standardize a value. From what I've seen, its more related to movement.

The use of glm::lookAt serves as a shortcut to creating a usable camera in the desired space in the correct orientation. This function essentially creates a local space for the object to abide by, which the computation done inside is usually meant to match the orientation of the local space to the world space. The difficult part comes from creating a dynamic camera. The movement of the camera via WASD keys isn't too difficult to wrap your mind around. We need a vector that tells us which way the camera faces. Keep in mind that the glm::lookAt function takes in 3 vectors; the camera position in world space, the vector in which the camera is facing, and the vector that points in the up direction that helps with the orientation of the camera. Given these values, we can break down the method of moving in the 4 cardinal directions. To move forward, we simply use the vector that points the camera forward and add it to the camera's position. Similarly, we can subtract this value instead to go backwards. To head to the right, we can use the cross product to determine the vector that points directly to the right. Theoretically, the vector that points foward and the vector that points up should be perpendicular. This means that the cross product of the two should create another vector thats perpendicular to both vectors. In abiding by the right hand rule and inputting the front facing vector first, then the orientation vector, we get a vector that points directly to the right. We can then simply add the vector to the camera position to move to the right. Once again, we can use the same vector but subtract instead to travel to the left. If you inputted the up vector first then the front vector for the cross product, you will get a vector point to the left instead.

Now for the curor and rotation part: yaw, pitch, and roll. We won't be using roll for this camera, so it'll just be yaw and pitch. To break this down as much as I can starting at a higher level and moving down, yaw is essentially the ability to turn the camera left and right. To be able to understand the logic behind it, we must consult the unit circle. When looking left and right, what can be understood is that our camera is rotating around the y axis. To best understand this, we must imagine ourselves position on the y axis, looking down and seeing the x and z axis infront. Furthermore, imagine that there is a unit circle on the xz plane, where x remains in the same location, while z now takes on the location of the y axis in a 2D plane. When consulting a unit circle, we know that when traveling around a circle, cosine represents the x axis, and sine represents the y axis. In a more mathematical manner, in computing SohCahToa, it will be from the perspective from the angle at the origin. This means that in computing Sine = opposite/hypotenuse, where hypotenuse = 1 since its a unit circle where the radius is a unit of 1, we can see it as sine = opposite / 1, or sine = opposite. Here, opposite is parallel to the supposed y axis, as such we can say that sin(theta) = y. In calculating cosine, cosine = adjacent / hypotenuse, or adjacent / 1, meaning consine = adjacent. This means that we can then simplify this to cosine(theta) = x. Evidently this can be seen when traversing the unit circle, the coordinate always corresponds to the value of (cos, sin). With this hopefully settled, going to the yaw rotation in looking left to right, we are essentially moving on the xz plane. Given the reasoning of x aligning to the x axis and z aligning to the y axis, referring to the unit circle, to represent the rotation correctly we must add the sin and cos of yaw to their respect axes. The x axis rotation can be computed by cos(yaw), while the z axis rotation can be computed by sin(yaw). I'm sorry about how convoluted this is, I'm sure there is a better mathematical reason that you can use to solve for these equations, but I just am unaware of it.
Moving on to pitch, this essentially represents our camera looking up and down. We can unfortunately use the same reasoning, however instead we take the perspective of the x axis, looking at the yz plane. This time around, z takes on the position of the x axis, and y takes on the position of the y axis. As such, cos(pitch) computes the positioning of the z axis, and sin(pitch) calculates the position of the y axis. That however does not consider all possible factors involving what we want out of the camera. In a generic game involving character POVs, when you look down, usually you aren't able to then look to the left or right. To account for this, we must add cos(pitch) to the x axis to prevent this unnatural movement for a camera. I'm not too informed about this topic, however I feel like preventing this camera movement just feels more natural for the player and akin to real life. I feel like this also some how correlates with gimbals lock, although I'm not too informed about this, just that quaternions solve the problem.

With this module completed, this now marks the end of OpenGL basics. The next step would to now be head towards lighting, however I may try to create some project first before hand just to hammer in the entire workflow of OpenGL.

I do need to create libraries more libraries to make things move along faster, but perhaps I should try to code without libraries first? I'm not sure, but I'll get something done before moving on to lighting.

Next Day: I will create a general workflow for low level OpenGL, then I'll create the libraries from scratch. First and foremost though, I will complete this module's exercise.

Exercise completed, annoyed by row major vs column major.
