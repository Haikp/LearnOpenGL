# Contents of this Branch
## Also Contains Module 09_Materials, was too small to make a separate branch for it
More pressing matters, I want to vent my ideas about Phong shading here. As if writing this paragraph, I have not yet finished the module, but I want to be able to digest the first two out of three parts to Phong Shading. So, the three parts of Phong shading are ambience, diffusion, and specular lighting. Ambience in itself is straightforward, replicating the innate nature of light bouncing around and allowing shady areas to not be pitch black in real life. Essentially, take the color of the light, and scale it down as if the light isn't touching it, which in this example its by a factor of .1. In the case of diffusion, the initial math makes a lot of sense, which I was able to make my own informed decisions as to how this is done with dot products and normals, and it checks out that the prior studying I did paid off. The small road block I'm having currently is that I don't particularly understand the normal matrix, using the transpose and inverse function on the model matrix. I don't think that I can reason my way through this one just yet, so I'll take a look in to this normal matrix, and get back to it.

As of this paragraph, I have now completed wthe Phong Module, and there is rather a lot to unpack with things I did or tried to do. From the beginning, phong is composed to three components, the ambience, diffusion, and the specular lighting. I will attempt to type out my understanding of the three stages, just as a way to help me remember what I learned from reading other sources.

The ambience lighting can be understood as the indirect visibility created by light bouncing around in real life. The implementation of this step is the easiest of the three components, essentially coloring the fragment by a determined decimal value of the light's color.

NOTE: ALL VECTORS USED HERE ARE NORMALIZED, PLEASE AND THANK YOU.

The diffusion component is the part where light becomes more dynamic, and lights up the correct surfaces that the light particles realistically touch. Shining a light on a cube, the face that is most aligned with the light will be the brightest, while the other sides of the faces are vary in intensity, with the opposing faces being dim. To correctly implement, we will need two vectors: the vector point from the fragment to the light source, and the surface normal. As of this module, we manually send the surface normal through attributes. I feel like I recall there being a better way, especially for more complicated surfaces, but this is fine for now. As for the vector from fragment to light source, we need to send in the position of the light source as a uniform and compute fragmentPosition - lightPosition. From here, we now have two vectors that point from the fragment, and outwards. Logically understanding light, if a light source is facing head on with a surface, the the surface should the brightest it can be. As such, give these two vectors, we can determine now aligned that face of the cube is with the light source by computing the dot product. If the surface normal is in line with the resulting vector, or the angle between them is small, then the face should be lit up. We can use the value from the dot product, being clamped to 1 - 0, to determine how bright a face should be. As a reminder, if two vectors are parallel, then the resulting value from the dot product is 1, fitting our needs. The value can be used as a scalar to determine the brightness of the light.

The specular component represents the intensity of the light on a specific point of the fragment depending on the camera's position. This can be compared to the reflective glare of the sun on a shiny surface. The computation of this took a lot longer than expected to understand, but after taking a look, the process makes sense. As a prerequisite with understanding this, when computing the dot product, the orientation of the vectors are important. In our case with lighting, the vectors we are use are to potentially both point away from each other, OR towards each other. This will result in a positive value if the angle formed between them is acute. For consistency sake, just follow that rule. With that in mind, there are once again two vectors that we need to calculate the specular value: the vector from the fragment to the camera, and the vector that is generated by reflecting the vector from the light to fragment. To find the reflected fragment, we will be using the builtin shader function "reflect" which requires the vector we are reflecting to point towards where we are reflecting around. In this case, since we are reflecting of off a surface, we will use that surfaces' normal. The resuling reflected vector actually now points outwards from the fragment. Using the two vectors that now point away from the fragment, we will now compute the dot product between the reflected vector and the vector from fragment to camera position. In successfully implementing this, we can see a brighter, more focused dot of bright light on the surface.

To combine the three components, simply add them together and multiply by the objects intended color.

The aspect of this module that took the most time, and yet unfortunately I dont particularly understand, is how normal vectors are computed once the fragment has transformed. I understand that to find the transformation of a normal vector, we take the transpose of the inverse of the model matrix, then apply that to the normal vector. Most of the links I found led to mathematical proofs for why this is this case, however I wanted to see a visual representation, seeing how the model matrix is slowly morphed in to the required matrix to move the normal vector. For now though, it seems that I'll have to be satisfied with simply know the normal matrix.

Something that's potentially worth mentioning is the gouraud shading method. This process all follows the exact same as phong shading, however instead of computing it all on the fragment shader, the gouraud shading method computes it all on the vertex shader. This improves performance as the gouraud actually only goes through and computes lighting from the vertex, and interpolates the values from there. This means that gouraud only runs as many times as there are vertices to draw, per draw call, versus the fragment shader running as many times as there are pixels that need to be colored properly.

## Module 09_Materials Section
The module in itself is not difficult to implement, rather the whole module was adding two structs to the shaders to use. As such, I used my time today to mess with the values of ambience, diffusion, specular, and now shininess. Ambience and diffusion is straightforward to me at this point and is now solidified after tampering with the values. As for specular and shininess, I have a hard time wrapping my head around the difference between the two. I believe I do have the right idea though after comparing them both and looking up a few things: specular refers to how bright the light reflected off the fragment will be, while shininess refers to how well in terms of reflective quality the light will be reflected, like the sharpness of the light reflected. I compared all combinations of the two varaibles, and saw that the brightness really does stay relatively when specular is maxed and shininess is the variable. The noticably visible difference is how the light disperses on the surface, with higher shininess having a more concise and gathered light, versus the more scatter bright light with low shininess.

To add to convenience, there are two structs that were added, with the material struct that has been used for the majority of the time to determine the fragments color, and now the light struct to determine the color of the light. The material struct determines the color of the material under the context that the light is white. The light struct can affect the color of the fragment after to combine the colors computationally. This isn't a difficult topic to grasp in itself, but looking at it from a different perspective, it feels like I never exactly set the color of the cube manually. This will be just be rambling from here, but there was something that was hard to grasp when it came to not initially setting the color of the cube before doing all the lighting. Just thinking that the material struct is how the object will react under white light is what helped me understand. I don't think I'll need a different perspective other than that for a basic grasp of lighting for now, so I'll just leave it at that probably.
