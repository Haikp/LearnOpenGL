# Contents of this Branch
This module is the second to last lighting module, and it infact did have a lot of content that needs to be covered. There were 3 lighting methods, each having practical applications: directional light, point light, and spot light.

Directional light can be understood as a light source that is distant yet effective to all objects in sight. A good example of such would be the sun. The implementation is pretty straight forward, being that we will be supplying our object with a vector that the light source points from. Using the sun, it would point from the sun, down to earth and light up our object. From what we already know about lighting, usually our calculations are done calculating a vector starting from the object to the light source. This is because we are using this vector to compute the dot product with our surface normal for the diffuse, which also points away from our object. Since the directional light is pointing from light source to object, we must flip it around by using the negative version of the vector. With that, we can now compute the diffuse value as usual. As for the specular value, the vector is actually already in the correct orientation, point from light source to object, thus we can just reflect it, and compare the new vector with the vector that points from object to camera, and compute the dot product.

Point light is essentially an external source of light that fades with distance. An example of such would be a campfire. The implementation of this is nearly the exact same as implementing a light source emitting from our light cube, except that we need to add an equation that diminishes intensity of the light with distance. 1 / light constant + light linear * distance + light quadratic * distance^2. It's a straightfoward equation that can be visualized on desmos if need to see a nice downward curve. Add the equation by computing the distance from light source to a fragment, and that is the variable to input to the equation. To note, the value that diminishes the brightness of the light is call the attenuation, which keep in mind this must be multipled to the diffuse and specular light. The module does multiply it to the ambient value, but I don't think its necessary, since its value is already the absence direct light contact, meaning the campfire shouldn't affect it.

The last one is the spotlight, which did take a while to understand the equation, but the name speaks for it self as an example, being a spot light, or a flashlight depending on how its implemented. In my case, it was used to create a flashlight. Intuitively, to create a flashlight, we will need the camera position, the vector pointing towards where the camera is facing, and the desired circle size of our light. Just as a note, we can actually use the attenuation variable from point light as a way to put a distance limit on the flashlight. In a majority of the cases, we have been calculating the angles and such from the perspective of the fragment, to something else like the light object, bottom line being that the vectors pointed away from the fragment. This makes sense as all vectors will start from that same point and being much easier to visualize, as opposed to multiple vectors coverging on to one point. It's like all the vectors are sprouting out of that pixel. This time however, all of our vectors are come from the camera this time around, so our math will now be from that perspective. At this point, computing light shouldn't be difficult to do. So the only issue that comes up is how to limit the light to only exist in our desired circle. I'll try to break this up in to multiple pieces, using as many real world examples to compare it to, what part of the flashlight to think of.

Since we are creating a flashlight, we will be first needing to know which way the light should point. We want the light to come from our camera, and move dynamically, as such we will need the vector that points to where the camera is facing. We should already have the correct vectors, being the camera's current position in world space, and the point in which its supposed to look at in world space, which based off the the camera class, is simply one unit infront of the camera. To get our desired vector, we compute camera position minus camera front orientation.

The next vector we need is the vector that indicates the cone of our flashlight. At first this was rather confusing to understand solely looking at the value we passed in. In the module, I passed in the cosine value associated with 12.5 degrees in radians. This is not the radius clearly, nor is it saying that our light will be a triangle that has a cosine angle of 12.5 degrees. To be able to understand what this number really means, we must view this from a 3rd plane. But first, to reivew about circles and cosine, understand that points on the unit circle, the x coordinate is the value of cosine. Imagine the 3D space grid with our camera looking at the xy plane while being on the z axis. Now also image a circle that is on the xz plane, where the center of the circle is on the camera and the point (0, 1) of the unit circle is aligned with the camera's front facing direction. If you open an angle such that you make a 12.5 degree angle at the unit circle, and rotate the whole circle on the z axis such that the angle creates a cone, THAT is the cone of light for the flashlight. That's the best I can do with trying to verbally describe the flashlight. This is what we are calculating for the flashlight when passing in the value 12.5. To continue on with the calculations now, we currently have the vector that points forward generally from the camera. We now need to find the vector that connects from the fragment to the camera itself. We then calculate the dot product between these two vectors to find angle between the two, to which if the angle found is inside the cone of light, then light up that pixel in the fragment shader. The tricky part about this however is when comparing values, we actually want to find values where the theta found is actually greater than our cut off cone of 12.5 degrees. This is due to us using the cosine for our flashlight. Referring back to the unit circle, and the angle we want. In our case of an angle of 12.5 degrees, we want any pixel thats within that, so less than 12.5 degrees to light up. Whats important to pay attention to is again the x, or cosine, value. As we open up the angle on the unit circle, our x value decreases, and as we approach 0 degrees, our x value approaches 1. this means, the range  that we want is from cosine(radian(12.5)) to the value of 1 to cover that sliver on the unit circle that we want. That is indeed the hard part done. Now, if the pixels fall within this cone, light it up using ambient, diffuse, and specular lighting, otherwise use only the ambient lighting.

As a bonus in the module, we can smooth out our flashlight around the edges. In the paragraph above, when done correctly, we create a flashlight with a harsh edge around the circle of light. We can smooth this out using a second, larger cone to linearly fade out the light at the edge. On the module, for some reason they said the equation was daunting, but it's not too complicated once broken down.. unlike the last paragraph. To preface what this function will do, image an extremely bright spot in the middle, which will gradually diminish as it gets to the edges. That's what the function essentially is, given that we also clamp the light values between 0 and 1 for our purpose, so that the center of the light isnt extraordinarily bright, or the edges I presume to be inverted colors of some sort. To break down the equation, we can start with the denominator, epsilon. This entails the inner cone minus the outer cone. the inner cone has the higher value here despite being a thinner cone because of its consine value being larger. This value essentially states that as long as the number exceeds this denominator, or in this case if the pixel we are looking at is close enough to the center within the parameter, it will be lit up to the most it can be. If the numerator is under the value of the denominator, then the light value will be diminished, with the lower the value, the darker it'll be, or in this context, the farther from the center it is, the dark it will be. Something to note, this function is a linear gradient. To discuss the numerator, essentially get the angle found, and subtract it by the outer cone to find out how far away from the edge of the circle it is. As said, the value return is from 0 to 1, which if the value of the pixel is within the cone, to apply this light intensity value properly, only multiply it to the diffuse and specular value, and add it to the final result summing ambient, diffuse, and specular as usual.

This chapter was actually really fun and challenging. I really felt like I learned a lot, and that my time that I spent reviewing about trig really paid off. I feel like I understand it enough to be able to teach it now, which was the goal in the first place.
