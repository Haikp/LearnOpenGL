# Contents of this Branch
This module contains more technical content, showing new or reintroducing variables in glsl with the prefix 'gl_', and presenting another way of organizing data. Similar to the previous module for 19_AdvancedData, this module once again uses SubData in order to optimize how we process our buffers, with this time around introducing the Uniform Buffer Object (ubo). The UBO can be understood as global variables that exists on the GPU, being able to be used by any shader that has the UBO binded.

An important aspect to declaring a UBO is knowing how the buffer will be allocated. In this example, we will be using the std140 layout, which is a more universal layout that modern computers should be able to use. The goal of this is to optimize graphics, but if the computer can't correctly set up and read the data, then all optimization is lost, thus making std140, something established in GLSL v1.40, the reliable standard. This makes it so that the layout the UBO must be inserted correctly, which isn't complicated once you accept the terms and conditions of the rules. I doubt that I could do better than the module at explaining how the data is meant to be set, but heres an attempt. There are two rules you need to follow is (1) all variables will be allocated a space of 4 bytes, if the variable needs more space, then 8 bytes will be given, if more is needed like a vec3, then 16 bytes will be given. (2) The offset in which the variable is given must be a multiple of its space that it is allocating. There will be unused/padded space in some cases.

In the case that the uniform buffer has an int followed by a vec3, the int will take 4 bytes, and the vec3 will take 16 bytes despite being able to fit in 12 bytes. As the int is first, the offset will be at 0, and it will occupy 4 bytes. For the vec3, we will need to allocate 16 bytes as the first rule implies, however we cannot simply append this to the end of the int, and have the offset start at 4. We must follow the second rule, and go by the base of 16, meaning that since we cannot fit it at 0 (16 * 0), we must go to 16 (16 * 1). This means that the offset will be at 16, and as such the space between, going from 4-15, will not be used.

There is an optimization here, where we should instead have the layout start with larger data types first. In the case of the example above, we take up 32 bytes for an int and a vec3. If we reverse the order instead, vec3 would take bytes 0 - 15, with an offset starting at 0, which then inserting the int, we can have the offset be at byte 16 since its a multiple of 4, and thus avoid padding altogether, saving 12 bytes (only bytes 0-19 were used instead of 0 - 31).

The use of UBOs is for efficiency, being it reduces the number of binding operations drastically. How you set it up does feel like how you would with a texture, unless you have OpenGL 4.2+, then its more like the array attrib pointer and much easier.
