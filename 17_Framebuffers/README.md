# Contents of this Branch
This module was very short, essentially one line of code that makes a huge difference in performance. Originally I had thought that culling was done automatically, but understanding that its best to leave it as a setting for people getting introduced to OpenGL makes sense. Knowing that it's not automatic though, I would also presume that frustum culling is not automatic either, which will be interesting topic to look in to. It appears that there is a module for frustum culling, so I'll leave the independent research for when I do reach this module.

So far, my current understanding is that the framebuffer really feels like a filter more than anything. This is definitely incorrect though, as you are able to render something like a rear view camera. The main premise behind these buffers is that you are able to render objects through the framebuffer. I will take more time and more research, and will update this README.md file.

Update: the frame buffer is not a filter

I have now finally completed making a 180 degree pov using another frame buffer, and I've come to a better understanding of framebuffers. I'm very much still uncomfortable using the really indepth parameters of the frame buffer, but I feel pretty good about using basic components. As far as my current understanding of frame buffers go, it is essentially the buffer in which you draw to before it gets outputted to the screen. After binding a frame buffer other than the default one, all draw calls are drawn to that frame buffer's texture thats empty when you generated it the first time. To print the custom frame buffer to screen, simply rebind the default frame buffer, and draw a basic square that covers the whole screen, using the texture in the frame buffer. Discussing it now, it really does seem very simple to implement a frame buffer.

To properly implement a 180 degree view, a new frame buffer is required. First of all, draw as you would normally, using the appropriate shaders and draw calls, then swap to the original framebuffer, bind the custom framebuffers texture, and output a simple square covering the whole screen, NO MVP MATRIX. This will be our main view of the scene. To render the 180 camera, you must now bind a new framebuffer, and once again redraw the entire scene. If it isn't clear, a draw call is drawn only on to the current frame buffer it is attached to. Continue the steps, bind the original frame buffer, this time attach the texture to a smaller square in a corner with no MVP matrix again, and that should be the general idea. The view matrix will need to be implement, and also don't clear the color buffer on the second frame buffer draw call, and that should be good.

Again, I don't have much down for the frame buffer, but I believe that I will learn about the parameters a little more from the modules to come, probably. If not, I'll revisit this module and do some more self study. Either that or I'll just move on to PBR as intended.

Also, framebuffers are used for post processing, and it makes sense now as to why, which if you do want to apply some post processing, you would apply it to the framebuffer's draw call of a square.
